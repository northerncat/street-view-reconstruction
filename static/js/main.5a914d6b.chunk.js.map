{"version":3,"sources":["utils/StreetViewUtility.ts","DepthMapVisualization.tsx","serviceWorker.ts","index.tsx"],"names":["create2DArray","width","height","array","Array","h","getStreetViewDepthDataUrl","options","Object","keys","map","key","encodeURIComponent","join","StreetViewUtility","lat","long","url","output","ll","dm","fetch","then","response","ok","Error","statusText","json","rawDepthMapData","callback","length","replace","inflate","Buffer","from","error","result","dataView","buf","Uint8Array","i","DataView","buffer","toDataView","metaData","getDepthMapMetaData","geometry","getStreetViewGeometry","depthImage","getDepthImage","bufferData","metaDataSize","getUint8","numberOfPlanes","getUint16","offset","planes","planeIndices","w","planesStartIndex","p","n","x","getFloat32","y","z","d","v1","v2","theta","Math","PI","sinTheta","sin","cosTheta","cos","planeIndex","phi","viewDirection","plane","distance","abs","LATITUDE","parseFloat","split","LONGITUDE","PLANE_INDEX_VIZ_COLORS","0","1","2","3","4","5","6","App","useState","undefined","depthMap","setDepthMap","setDepthImage","loadDataCallback","useEffect","fetchStreetViewImage","parseDepthMapString","model","depth_map","console","log","canvas","document","getElementById","ctx","getContext","clearRect","indices","imageData","createImageData","index","color","data","putImageData","depthMapData","className","id","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.5a914d6b.chunk.js","sourcesContent":["import { inflate } from 'zlib';\r\n\r\nexport interface Point {\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n};\r\n\r\nexport interface StreetViewPointCloud {\r\n    width: number,\r\n    height: number,\r\n    points: Point[][],\r\n};\r\n\r\nexport type DepthImage = Array<Array<number>>;\r\n\r\nexport interface Vector {\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n};\r\n\r\nfunction dot(v1: Vector, v2: Vector) : number {\r\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\r\n};\r\n\r\nexport interface Plane {\r\n    n: Vector,\r\n    d: number,\r\n};\r\n\r\nexport interface DepthMapMetaData {\r\n    metaDataSize: number,\r\n    numberOfPlanes: number,\r\n    width: number,\r\n    height: number,\r\n    offset: number,\r\n};\r\n\r\nexport interface StreetViewGeometry {\r\n    width: number,\r\n    height: number,\r\n    planeIndices: number[][],\r\n    planes: Plane[],\r\n};\r\n\r\nexport interface StreetViewDepthMap {\r\n    metaData: DepthMapMetaData,\r\n    bufferData: DataView,\r\n    geometry: StreetViewGeometry,\r\n};\r\n\r\nexport interface StreetViewResponse {\r\n    model: {\r\n        depth_map: string,\r\n    },\r\n};\r\n\r\nexport type DepthMapCallback = ([depthMap, depthImage]: [StreetViewDepthMap, DepthImage]) => void;\r\n\r\nfunction toDataView(buf: Buffer) : DataView {\r\n    const array = new Uint8Array(buf.length);\r\n    for (var i = 0; i < buf.length; ++i) {\r\n        array[i] = buf[i];\r\n    }\r\n    return new DataView(array.buffer);\r\n};\r\n\r\nfunction create2DArray<T>(width: number, height: number) : T[][] {\r\n    const array : T[][] = new Array<Array<T>>(height);\r\n    for (let h = 0; h < height; h++) {\r\n        array[h] = new Array<T>(width);\r\n    }\r\n    return array;\r\n};\r\n\r\nfunction getStreetViewDepthDataUrl(options : {[key: string] : any}) : string {\r\n    const queryString : string = Object.keys(options)\r\n        .map((key) => encodeURIComponent(key) + '=' + encodeURIComponent(options[key]))\r\n        .join('&');\r\n    return 'http://maps.google.com/cbk?' + queryString;\r\n}\r\n\r\nexport default class StreetViewUtility {\r\n\r\n    static fetchStreetViewImage(lat: number = 0.0, long: number = 0.0) : Promise<StreetViewResponse> {\r\n        const url = getStreetViewDepthDataUrl({ output: 'json', ll: `${lat},${long}`, dm: 1 });\r\n        return fetch(url)\r\n            .then((response) => {\r\n                if (!response.ok) {\r\n                    throw new Error(response.statusText);\r\n                }\r\n                return response.json();\r\n            });\r\n    }\r\n\r\n    static parseDepthMapString(rawDepthMapData: string, callback: DepthMapCallback) : void {\r\n        \r\n        while (rawDepthMapData.length % 4 !== 0) {\r\n            rawDepthMapData += '=';\r\n        }\r\n        rawDepthMapData = rawDepthMapData.replace(/-/g, '+');\r\n        rawDepthMapData = rawDepthMapData.replace(/_/g, '/');\r\n\r\n        inflate(Buffer.from(rawDepthMapData, 'base64'), (error: Error | null, result: Buffer) => {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            const dataView : DataView = toDataView(result);\r\n            const metaData : DepthMapMetaData = StreetViewUtility.getDepthMapMetaData(dataView);\r\n            const geometry : StreetViewGeometry = StreetViewUtility.getStreetViewGeometry(metaData, dataView);\r\n            const depthImage : number[][] = StreetViewUtility.getDepthImage(geometry);\r\n            callback([\r\n                {\r\n                    metaData,\r\n                    bufferData: dataView,\r\n                    geometry,\r\n                },\r\n                depthImage\r\n            ]);\r\n        });\r\n    }\r\n\r\n    static getDepthMapMetaData(buffer: DataView) : DepthMapMetaData {\r\n        return {\r\n            metaDataSize: buffer.getUint8(0),\r\n            numberOfPlanes: buffer.getUint16(1, true),\r\n            width: buffer.getUint16(3, true),\r\n            height: buffer.getUint16(5, true),\r\n            offset: buffer.getUint16(7, true),\r\n        };\r\n    }\r\n\r\n    static getStreetViewGeometry(metaData: DepthMapMetaData, buffer : DataView) : StreetViewGeometry {\r\n        const planes : Plane[] = new Array<Plane>(metaData.numberOfPlanes);\r\n        const planeIndices : number[][] = create2DArray<number>(metaData.width, metaData.height);\r\n        \r\n        // parsing referenced from https://github.com/proog128/GSVPanoDepth.js\r\n        for (let h = 0; h < metaData.height; h++) {\r\n            for (let w = 0; w < metaData.width; w++) {\r\n                planeIndices[h][w] = buffer.getUint8(metaData.offset + w + h * metaData.width);\r\n            }\r\n        }\r\n\r\n        const planesStartIndex = metaData.offset + metaData.height * metaData.width;\r\n        for (let p = 0; p < metaData.numberOfPlanes; ++p) {\r\n            // each plane is represented by four 32-bit floats\r\n            const offset : number = planesStartIndex + p * 4 * 4;\r\n            planes[p] = {\r\n                n: {\r\n                    x: buffer.getFloat32(offset, true),\r\n                    y: buffer.getFloat32(offset + 4, true),\r\n                    z: buffer.getFloat32(offset + 8, true),            \r\n                },\r\n                d: buffer.getFloat32(offset + 12, true),\r\n            };\r\n        }\r\n        return { width: metaData.width, height: metaData.height, planes, planeIndices };\r\n    }\r\n\r\n    static getDepthImage(geometry: StreetViewGeometry) {\r\n        const depthImage : number[][] = create2DArray(geometry.width, geometry.height);\r\n\r\n        // parsing referenced from https://github.com/proog128/GSVPanoDepth.js\r\n        for (let h = 0; h < depthImage.length; h++) {\r\n            const theta : number = (geometry.height - h - 0.5) / geometry.height * Math.PI;\r\n            const sinTheta : number = Math.sin(theta);\r\n            const cosTheta : number = Math.cos(theta);\r\n            for (let w = 0; w < depthImage[0].length; w++) {\r\n                const planeIndex : number = geometry.planeIndices[h][w];\r\n                if (planeIndex > 0) {\r\n                    const phi : number = (geometry.width - w - 0.5) * 2 * Math.PI / geometry.width;\r\n                    const viewDirection : Vector = {\r\n                        x: sinTheta * Math.cos(phi),\r\n                        y: sinTheta * Math.sin(phi),\r\n                        z: cosTheta,\r\n                    };\r\n                    const plane : Plane = geometry.planes[planeIndex];\r\n                    const distance : number = Math.abs(plane.d / (dot(plane.n, viewDirection)));\r\n                    depthImage[h][w] = distance;\r\n                } else {\r\n                    depthImage[h][w] = 0.0;\r\n                }\r\n            }\r\n        }\r\n        return depthImage;\r\n    }\r\n\r\n};","import React, { useState, useEffect } from 'react';\nimport './DepthMapVisualization.css';\nimport StreetViewUtility, { StreetViewResponse, StreetViewDepthMap, DepthMapCallback, DepthImage } from './utils/StreetViewUtility';\n\nconst LOCATION_STRING = '37.7769799,-122.3949447';\nconst LATITUDE: number = parseFloat(LOCATION_STRING.split(',')[0]);\nconst LONGITUDE: number = parseFloat(LOCATION_STRING.split(',')[1]);\n\nconst DEPTH_IMAGE_VIZ_FACTOR : number = 2.5;\nconst PLANE_INDEX_VIZ_COLORS : {[key: number] : number[]} = {\n    0: [255, 255, 255],\n    1: [255, 0, 0],\n    2: [0, 255, 0],\n    3: [0, 0, 255],\n    4: [255, 255, 0],\n    5: [255, 0, 255],\n    6: [0, 255, 255],\n};\n\nconst App : React.FC<{}> = () => {\n\n    const [depthMap, setDepthMap] = useState<StreetViewDepthMap | undefined>(undefined);\n    const [depthImage, setDepthImage] = useState<DepthImage|undefined>(undefined);\n\n    const loadDataCallback : DepthMapCallback = ([depthMap, depthImage]) => {\n        setDepthMap(depthMap);\n        setDepthImage(depthImage);\n    };\n\n    const loadStreetViewData = (): void => {\n        try {\n            StreetViewUtility.fetchStreetViewImage(LATITUDE, LONGITUDE)\n                .then((response : StreetViewResponse) => {\n                    StreetViewUtility.parseDepthMapString(response.model.depth_map, loadDataCallback);\n                });\n        } catch (error) {\n            // show error message\n            console.log(error);\n        }\n    };\n    useEffect(loadStreetViewData, []);\n\n    const drawDepthImage = false;\n    useEffect(() => {\n        const canvas = document.getElementById('depth-map') as HTMLCanvasElement;\n        if (!canvas) return;\n        const ctx : CanvasRenderingContext2D|null = canvas!.getContext('2d');\n        ctx?.clearRect(0, 0, 512, 256);\n        \n        if (depthImage && drawDepthImage) {\n            let maxDistance : number = 0.0;\n            const width : number = depthImage[0].length;\n            const height : number = depthImage.length;\n            const imageData : ImageData = ctx!.createImageData(width, height);\n            for (let h = 0; h < height; ++h) {\n                for (let w = 0; w < width; ++w) {\n                    const index = h * width + w;\n                    const grayScale = depthImage[h][w] * DEPTH_IMAGE_VIZ_FACTOR;\n                    imageData.data[index * 4] = grayScale;\n                    imageData.data[index * 4 + 1] = grayScale;\n                    imageData.data[index * 4 + 2] = grayScale;\n                    imageData.data[index * 4 + 3] = 255.0;\n                    maxDistance = Math.max(depthImage[h][w], maxDistance);\n                }\n            }\n            // console.log('Maximum distance: ', maxDistance);\n            ctx?.putImageData(imageData, 0, 0);\n        } else if (depthMap) {\n            const indices = depthMap.geometry.planeIndices;\n            const imageData : ImageData = ctx!.createImageData(depthMap.geometry.width, depthMap.geometry.height);\n            for (let h = 0; h < indices.length; ++h) {\n                for (let w = 0; w < indices[0].length; ++w) {\n                    const index = h * indices[0].length + w;\n                    const color = PLANE_INDEX_VIZ_COLORS[indices[h][w]];\n                    if (color) {\n                        imageData.data[index * 4] = color[0];\n                        imageData.data[index * 4 + 1] = color[1];\n                        imageData.data[index * 4 + 2] = color[2];\n                    }\n                    imageData.data[index * 4 + 3] = 255.0;\n                }\n            }\n            ctx?.putImageData(imageData, 0, 0);\n        }\n    }, [depthImage, depthMap, drawDepthImage]);\n\n    const depthMapData: JSX.Element|undefined = depthMap && (\n        <table>\n            <tbody>\n                <tr>\n                    <td>Number of Planes</td>\n                    <td>{depthMap.metaData.numberOfPlanes}</td>\n                </tr>\n            </tbody>\n        </table>\n    );\n\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <label>Latitude: {LATITUDE}</label>\n                <label>Longitude: {LONGITUDE}</label>\n                <br/>\n                {depthMapData}\n                <br/>\n                <canvas id='depth-map' width={512} height={256}/>\n            </header>\n        </div>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport DepthMapVisualization from './DepthMapVisualization';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <DepthMapVisualization />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}